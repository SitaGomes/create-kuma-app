// delegate/notification.realtime.delegate.service.ts
import { Database } from 'firebase-admin/database';
import { Notification } from 'src/data/models/notification.model';
import { RealtimeService } from './realtimeService';

export class NotificationDelegateService extends RealtimeService<Notification> {
  private realtimeDB: Database;

  constructor(realtimeDB: Database) {
    super('products');
    this.realtimeDB = realtimeDB;
  }

  // Construct the reference path for notifications for a given organization and user
  _getRef(orgId: string, userId: string) {
    return this.realtimeDB.ref(`orgs/${orgId}/users/${userId}/notifications`);
  }

  _toModel(obj: any): Notification {
    const {
      id,
      title,
      message,
      read,
      createdDate,
      updatedDate,
      type,
      userId,
      action,
    } = obj;

    const cDate = createdDate?.toDate
      ? createdDate.toDate()
      : new Date(createdDate);
    const uDate = updatedDate?.toDate
      ? updatedDate.toDate()
      : new Date(updatedDate);

    const model = new Notification(
      title,
      message,
      type,
      userId,
      action,
      read,
      id,
      cDate,
      uDate,
    );

    return model;
  }

  _toObject(model: Notification) {
    return {
      id: model.id,
      title: model.title,
      message: model.message,
      action: model.action,
      read: model.read,
      type: model.type,
      userId: model.userId,
      createdDate: model.createdDate,
      updatedDate: new Date(),
    };
  }

  _orderBy(a: Notification, b: Notification): number {
    return RealtimeService.compareByDate(a, b);
  }

  // Create a new notification
  async create(
    orgId: string,
    userId: string,
    notification: Notification,
  ): Promise<string> {
    const ref = this._getRef(orgId, userId);
    const newNotificationRef = ref.push();
    // Set the id from the key generated by push
    notification.id = newNotificationRef.key as string;
    notification.createdDate = new Date();
    notification.updatedDate = new Date();

    await newNotificationRef.set({
      id: notification.id,
      type: notification.type,
      userId: notification.userId,
      title: notification.title,
      message: notification.message,
      action: notification.action,
      read: notification.read,
      createdDate: notification.createdDate.toISOString(),
      updatedDate: notification.updatedDate.toISOString(),
    });

    return notification.id;
  }

  // Update an existing notification
  async update(
    orgId: string,
    userId: string,
    notification: Notification,
  ): Promise<void> {
    const ref = this._getRef(orgId, userId);
    notification.updatedDate = new Date();

    await ref.child(notification.id).update({
      title: notification.title,
      message: notification.message,
      read: notification.read,
      updatedDate: notification.updatedDate.toISOString(),
    });
  }

  // Delete a notification
  async delete(
    orgId: string,
    userId: string,
    notificationId: string,
  ): Promise<void> {
    const ref = this._getRef(orgId, userId);
    await ref.child(notificationId).remove();
  }

  // Retrieve all notifications for a user
  async findMany(orgId: string, userId: string): Promise<Notification[]> {
    const ref = this._getRef(orgId, userId);
    const snapshot = await ref.once('value');
    const notificationsData = snapshot.val();

    if (!notificationsData) return [];

    // Convert the object map to an array of Notifications
    return Object.values(notificationsData).map((data: any) => {
      return new Notification(
        data.title,
        data.message,
        data.type,
        data.userId,
        data.action,
        data.read,
        data.id,
        new Date(data.createdDate),
        new Date(data.updatedDate),
      );
    });
  }

  // Mark a notification as read
  async markAsRead(
    orgId: string,
    userId: string,
    notificationId: string,
  ): Promise<void> {
    const ref = this._getRef(orgId, userId);
    await ref.child(notificationId).update({
      read: true,
      updatedDate: new Date().toISOString(),
    });
  }

  async findUnique(
    orgId: string,
    userId: string,
    notification: string,
  ): Promise<any> {
    return this._getDocAsync(notification, orgId, userId);
  }
}
